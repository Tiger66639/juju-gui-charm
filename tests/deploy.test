#!/usr/bin/env python2
#-*- python -*-

import unittest
import urlparse

from charmhelpers import make_charm_config_file
from selenium.webdriver import Firefox
from selenium.webdriver.support import ui
from xvfbwrapper import Xvfb

from helpers import (
    legacy_juju,
    juju,
    jujuenv,
    ssh,
    wait_for_service,
)


JUJU_GUI_TEST_BRANCH = 'lp:~juju-gui/juju-gui/charm-tests-branch'
STAGING_SERVICES = ('haproxy', 'mediawiki', 'memcached', 'mysql', 'wordpress')
is_legacy_juju = legacy_juju()


class DeployTestMixin(object):

    charm = 'juju-gui'
    port = '443'

    def setUp(self):
        # Perform all graphical operations in memory.
        vdisplay = Xvfb(width=1280, height=720)
        vdisplay.start()
        self.addCleanup(vdisplay.stop)
        # Create a Selenium browser instance.
        selenium = self.selenium = Firefox()
        self.addCleanup(selenium.quit)

    def tearDown(self):
        juju('destroy-service', '-e', jujuenv, self.charm)

    def assertEnvironmentIsConnected(self):
        """Assert the GUI environment is connected to the Juju API agent."""
        self.wait_for_script(
            'return app.env.get("connected");',
            error='Environment not connected.')

    def make_config_file(self, options=None):
        """Create a charm config file adding, if required, the Juju GUI source.

        Return the created config file object.

        This is just a simple wrapper around
        ``charmhelpers.make_charm_config_file``.
        """
        if options is None:
            options = {}
        return make_charm_config_file({self.charm: options})

    def handle_browser_warning(self):
        """Overstep the browser warning dialog if required."""
        self.wait_for_script(
            'return window.isBrowserSupported',
            error='Function isBrowserSupported not found.')
        script = 'return window.isBrowserSupported(navigator.userAgent)'
        supported = self.selenium.execute_script(script)
        if not supported:
            continue_button = self.wait_for_css_selector(
                '#browser-warning input',
                error='Browser warning dialog not found.')
            continue_button.click()

    def navigate_to(self, hostname, path='/'):
        """Load a page using the current Selenium driver.

        The page URL is calculated using the provided *hostname* and *path*.
        Retry loading the page until the page is found or a timeout exception
        is raised.
        """
        base_url = 'https://{0}:{1}'.format(hostname, self.port)
        url = urlparse.urljoin(base_url, path)

        def page_ready(driver):
            driver.get(url)
            return driver.title == 'Juju Admin'
        self.wait_for(page_ready, error='Juju GUI not found.')

    def wait_for(self, condition, error=None, timeout=20):
        """Wait for condition to be True.

        The argument condition is a callable accepting a driver object.
        Fail printing the provided error if timeout is exceeded.
        Otherwise, return the value returned by the condition call.
        """
        wait = ui.WebDriverWait(self.selenium, timeout)
        return wait.until(condition, error)

    def wait_for_css_selector(self, selector, error=None, timeout=20):
        """Wait until the provided CSS selector is found.

        Fail printing the provided error if timeout is exceeded.
        Otherwise, return the value returned by the script.
        """
        condition = lambda driver: driver.find_elements_by_css_selector(
            selector)
        elements = self.wait_for(condition, error=error, timeout=timeout)
        return elements[0]

    def wait_for_script(self, script, error=None, timeout=20):
        """Wait for the given JavaScript snippet to return a True value.

        Fail printing the provided error if timeout is exceeded.
        Otherwise, return the value returned by the script.
        """
        condition = lambda driver: driver.execute_script(script)
        return self.wait_for(condition, error=error, timeout=timeout)

    def login(self, password):
        """Log in to access the Juju GUI using the provided *password*."""
        form = self.wait_for_css_selector('form', 'Login form not found.')
        passwd = form.find_element_by_css_selector('input[type=password]')
        passwd.send_keys(password)
        submit = form.find_element_by_css_selector('input[type=submit]')
        submit.click()

    def get_service_names(self):
        """Return the set of services' names displayed in the current page."""
        def services_found(driver):
            return driver.find_elements_by_css_selector('.service .name')
        services = self.wait_for(services_found, 'Services not displayed.')
        return set([element.text for element in services])

    def stop_services(self, hostname, services):
        # XXX 2012-11-29 frankban bug=872264:
            # Just invoking ``juju destroy-service juju-gui`` in tearDown
            # should execute the ``stop`` hook, stopping all the services
            # started by the charm in the machine. Right now this does not
            # work in pyJuju, so the same behavior is accomplished keeping
            # track of started services and manually stopping them here.
        target = 'ubuntu@{0}'.format(hostname)
        for service in services:
            ssh(target, 'sudo', 'service', service, 'stop')


class DeployTest(DeployTestMixin, unittest.TestCase):

    def deploy(self, config=None, force_machine=None):
        """Deploy and expose the Juju GUI charm. Return the service host name.

        Also wait until the service is exposed and the unit started.
        If config_path is provided, it will be used when deploying the charm.
        If force_machine is not None, the unit will be deployed in the
        specified machine.
        """
        args = ['deploy', '-e', jujuenv]
        if config is not None:
            config_file = self.make_config_file(config)
            args.extend(['--config', config_file.name])
        if force_machine is not None:
            args.extend(['--force-machine', str(force_machine)])
        args.append('local:{0}'.format(self.charm))
        juju(*args)
        juju('expose', '-e', jujuenv, self.charm)
        address = wait_for_service(self.charm)
        return address

    def test_api_agent(self):
        # Ensure the Juju GUI and API agent services are correctly set up.
        hostname = self.deploy()
        if is_legacy_juju:
            # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
            self.addCleanup(
                self.stop_services,
                hostname, ['haproxy', 'apache2', 'juju-api-agent'])
        self.navigate_to(hostname)
        self.handle_browser_warning()
        self.assertEnvironmentIsConnected()

    @unittest.skipUnless(is_legacy_juju, 'staging only works in pyJuju')
    def test_staging(self):
        # Ensure the Juju GUI and improv services are correctly set up.
        hostname = self.deploy({'staging': 'true'})
        # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
        self.addCleanup(
            self.stop_services,
            hostname, ['haproxy', 'apache2', 'juju-api-improv'])
        self.navigate_to(hostname)
        self.handle_browser_warning()
        self.assertEnvironmentIsConnected()
        # The staging environment contains five deployed services.
        self.assertSetEqual(set(STAGING_SERVICES), self.get_service_names())

    def test_branch_source(self):
        # Ensure the Juju GUI is correctly deployed from a Bazaar branch.
        hostname = self.deploy({'juju-gui-source': JUJU_GUI_TEST_BRANCH})
        if is_legacy_juju:
            # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
            self.addCleanup(
                self.stop_services,
                hostname, ['haproxy', 'apache2', 'juju-api-agent'])
        self.navigate_to(hostname)
        self.handle_browser_warning()
        self.assertEnvironmentIsConnected()

    @unittest.skipIf(is_legacy_juju, 'force-machine only works in juju-core')
    def test_force_machine(self):
        # Ensure the Juju GUI is correctly set up in the Juju bootstrap node.
        hostname = self.deploy(force_machine=0)
        self.navigate_to(hostname)
        self.handle_browser_warning()
        self.assertEnvironmentIsConnected()


if __name__ == '__main__':
    unittest.main(verbosity=2)
