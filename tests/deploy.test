#!/usr/bin/env python2
#-*- python -*-

import unittest
import urlparse

from charmhelpers import make_charm_config_file
from selenium.common import exceptions
from selenium.webdriver import Firefox
from selenium.webdriver.support import ui
from shelltoolbox import command
from xvfbwrapper import Xvfb


jitsu = command('jitsu')
juju = command('juju')
ssh = command('ssh')


class DeployTestMixin(object):

    def setUp(self):
        self.charm = 'juju-gui'
        self.port = '443'
        # Perform all graphical operations in memory.
        vdisplay = Xvfb(width=1280, height=720)
        vdisplay.start()
        self.addCleanup(vdisplay.stop)
        # Create a Selenium browser instance.
        selenium = self.selenium = Firefox()
        self.addCleanup(selenium.quit)
        self.wait = ui.WebDriverWait(selenium, 20)

    def tearDown(self):
        juju('destroy-service', self.charm)

    def assertEnvironmentIsConnected(self):
        """Assert the GUI environment is connected to the Juju API agent."""
        def connected(driver):
            return driver.execute_script('return app.env.get("connected");')
        self.wait.until(connected, 'Environment not connected.')

    def navigate_to(self, hostname, path='/'):
        """Load a page using the current Selenium driver.

        The page URL is calculated using the provided *hostname* and *path*.
        Retry loading the page until the page is found or a timeout exception
        is raised.
        """
        base_url = 'https://{0}:{1}'.format(hostname, self.port)
        url = urlparse.urljoin(base_url, path)

        def page_ready(driver):
            driver.get(url)
            return driver.title == 'Juju Admin'
        self.wait.until(page_ready, 'Juju GUI not found.')

    def login(self, password):
        """Log in to access the Juju GUI using the provided *password*."""
        def form_displayed(driver):
            try:
                return driver.find_element_by_css_selector('form')
            except exceptions.NoSuchElementException:
                return False
        form = self.wait.until(form_displayed, 'Login form not found.')
        password = form.find_element_by_css_selector('input[type=password]')
        password.send_keys('admin')
        submit = form.find_element_by_css_selector('input[type=submit]')
        submit.click()

    def get_service_names(self):
        """Return the set of services' names displayed in the current page."""
        def services_found(driver):
            return driver.find_elements_by_css_selector('.service .name')
        services = self.wait.until(services_found, 'Services not displayed.')
        return set([element.text for element in services])

    def stop_services(self, hostname, services):
        # XXX 2012-11-29 frankban bug=872264:
            # Just invoking ``juju destroy-service juju-gui`` in tearDown
            # should execute the ``stop`` hook, stopping all the services
            # started by the charm in the machine. Right now this does not
            # work, so the same behavior is accomplished keeping track of
            # started services and manually stopping them here.
        target = 'ubuntu@{0}'.format(hostname)
        for service in services:
            ssh(target, 'sudo', 'service', service, 'stop')


class DeployTest(DeployTestMixin, unittest.TestCase):

    def deploy(self, config_path=None):
        """Deploy and expose the Juju GUI charm. Return the service host name.

        Also wait until the service is started.
        If *config_path* is provided, it will be used when deploying the charm.
        """
        args = ['deploy', 'local:{0}'.format(self.charm)]
        if config_path is not None:
            args.extend(['--config', config_path])
        juju(*args)
        juju('expose', self.charm)
        jitsu(
            'watch', '--failfast', self.charm,
            '--state', 'started', '--open-port', self.port)
        address = jitsu('get-service-info', self.charm, 'public-address')
        return address.strip().split(':')[1]

    def test_api_agent(self):
        # Ensure the Juju GUI and API agent services are correctly set up.
        hostname = self.deploy()
        # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
        self.addCleanup(
            self.stop_services, hostname, ['juju-api-agent', 'juju-gui'])
        self.navigate_to(hostname)
        self.assertEnvironmentIsConnected()

    def test_customized_api_port(self):
        # It is possible to customize the port used by the websocket server.
        api_port = 8081
        config = {self.charm: {'juju-api-port': api_port}}
        config_file = make_charm_config_file(config)
        hostname = self.deploy(config_path=config_file.name)
        # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
        self.addCleanup(
            self.stop_services, hostname, ['juju-api-agent', 'juju-gui'])
        self.navigate_to(hostname)
        self.assertEnvironmentIsConnected()
        ws_url = self.selenium.execute_script(
            'return app.env.get("socket_url");')
        self.assertIn(str(api_port), ws_url)

    def test_staging(self):
        # Ensure the Juju GUI and improv services are correctly set up.
        config = {self.charm: {'staging': 'true'}}
        config_file = make_charm_config_file(config)
        hostname = self.deploy(config_path=config_file.name)
        # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
        self.addCleanup(
            self.stop_services, hostname, ['juju-api-improv', 'juju-gui'])
        self.navigate_to(hostname)
        self.assertEnvironmentIsConnected()
        # Log in using the staging password.
        self.login('admin')
        # The staging environment contains five deployed services.
        expected = set([
            'haproxy', 'mediawiki', 'memcached', 'mysql', 'wordpress'])
        self.assertSetEqual(expected, self.get_service_names())

    def test_branch_source(self):
        # Ensure the Juju GUI is correctly deployed from a Bazaar branch.
        config = {self.charm: {'juju-gui-source': 'lp:juju-gui'}}
        config_file = make_charm_config_file(config)
        hostname = self.deploy(config_path=config_file.name)
        # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
        self.addCleanup(
            self.stop_services, hostname, ['juju-api-agent', 'juju-gui'])
        self.navigate_to(hostname)
        self.assertEnvironmentIsConnected()


class DeployToTest(DeployTestMixin, unittest.TestCase):

    def deploy_to(self):
        """Deploy the Juju GUI charm in the Juju bootstrap node.

        Expose it and return the service host name.
        Also wait until the service is started.
        """
        # The id of the bootstrap node is 0 (the first node started by Juju).
        jitsu('deploy-to', '0', 'local:{0}'.format(self.charm))
        juju('expose', self.charm)
        jitsu(
            'watch', '--failfast', self.charm,
            '--state', 'started', '--open-port', self.port)
        address = jitsu('get-service-info', self.charm, 'public-address')
        return address.strip().split(':')[1]

    def test_api_agent(self):
        # Ensure the Juju GUI and API agent services are correctly set up in
        # the Juju bootstrap node.
        hostname = self.deploy_to()
        # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
        self.addCleanup(
            self.stop_services, hostname, ['juju-api-agent', 'juju-gui'])
        self.navigate_to(hostname)
        self.assertEnvironmentIsConnected()


if __name__ == '__main__':
    unittest.main(verbosity=2)
