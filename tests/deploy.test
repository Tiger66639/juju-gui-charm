#!/usr/bin/env python2
#-*- python -*-

import time
import unittest
import urllib2

from charmhelpers import make_charm_config_file
from shelltoolbox import command


jitsu = command('jitsu')
juju = command('juju')
ssh = command('ssh')


def open_url(url):
    """Return a file-like object representing the URL.

    Retries several times before failing, only catching URL errors because
    we only need to make sure that the service is reachable, not that the
    response is correct.
    """
    retries = 60
    while retries:
        try:
            return urllib2.urlopen(url)
        except urllib2.URLError as err:
            retries -= 1
            time.sleep(0.5)
    raise err


class DeployTestMixin(object):

    def setUp(self):
        self.charm = 'juju-gui'
        self.port = '443'

    def tearDown(self):
        juju('destroy-service', self.charm)

    def stop_services(self, hostname, services):
        # XXX 2012-11-29 frankban bug=872264:
            # Just invoking ``juju destroy-service juju-gui`` in tearDown
            # should execute the ``stop`` hook, stopping all the services
            # started by the charm in the machine. Right now this does not
            # work, so the same behavior is accomplished keeping track of
            # started services and manually stopping them here.
        target = 'ubuntu@{0}'.format(hostname)
        for service in services:
            ssh(target, 'sudo', 'service', service, 'stop')

    def check_services(self, hostname, ws_port=8080):
        """Check the services are listening on their tcp ports."""
        url = 'http://{0}:{1}'.format(hostname, self.port)
        response = open_url(url)
        self.assertEqual(200, response.getcode())
        ws_url = 'http://{0}:{1}/ws'.format(hostname, ws_port)
        # A bad request status code here means the websocket resource is found.
        # It would take an actual websocket client to properly interact with
        # the websocket server.
        with self.assertRaises(urllib2.HTTPError) as context_manager:
            open_url(ws_url)
        self.assertEqual(400, context_manager.exception.getcode())


class DeployTest(DeployTestMixin, unittest.TestCase):

    def deploy(self, config_path=None):
        """Deploy and expose the Juju GUI charm. Return the service host name.

        Also wait until the service is started.
        If *config_path* is provided, it will be used when deploying the charm.
        """
        args = ['deploy', 'local:{0}'.format(self.charm)]
        if config_path is not None:
            args.extend(['--config', config_path])
        juju(*args)
        juju('expose', self.charm)
        jitsu(
            'watch', '--failfast', self.charm,
            '--state', 'started', '--open-port', self.port)
        address = jitsu('get-service-info', self.charm, 'public-address')
        return address.strip().split(':')[1]

    def test_api_agent(self):
        # Ensure the Juju GUI and API agent services are correctly set up.
        hostname = self.deploy()
        # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
        self.addCleanup(
            self.stop_services, hostname, ['juju-api-agent', 'juju-gui'])
        self.check_services(hostname)

    def test_customized_api_port(self):
        # It is possible to customize the port used by the websocket server.
        config = {self.charm: {'juju-api-port': 8081}}
        config_file = make_charm_config_file(config)
        hostname = self.deploy(config_path=config_file.name)
        # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
        self.addCleanup(
            self.stop_services, hostname, ['juju-api-agent', 'juju-gui'])
        self.check_services(hostname, ws_port=8081)

    def test_staging(self):
        # Ensure the Juju GUI and improv services are correctly set up.
        self.services = ('juju-api-improv', 'juju-gui')
        config = {self.charm: {'staging': 'True'}}
        config_file = make_charm_config_file(config)
        hostname = self.deploy(config_path=config_file.name)
        # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
        self.addCleanup(
            self.stop_services, hostname, ['juju-api-improv', 'juju-gui'])
        self.check_services(hostname)


class DeployToTest(DeployTestMixin, unittest.TestCase):

    def deploy_to(self):
        """Deploy the Juju GUI charm in the Juju bootstrap node.

        Expose it and return the service host name.
        Also wait until the service is started.
        """
        # The id of the bootstrap node is 0 (the first node started by Juju).
        jitsu('deploy-to', '0', 'local:{0}'.format(self.charm))
        juju('expose', self.charm)
        jitsu(
            'watch', '--failfast', self.charm,
            '--state', 'started', '--open-port', self.port)
        address = jitsu('get-service-info', self.charm, 'public-address')
        return address.strip().split(':')[1]

    def test_api_agent(self):
        # Ensure the Juju GUI and API agent services are correctly set up in
        # the Juju bootstrap node.
        hostname = self.deploy_to()
        # XXX 2012-11-29 frankban bug=872264: see *stop_services* above.
        self.addCleanup(
            self.stop_services, hostname, ['juju-api-agent', 'juju-gui'])
        self.check_services(hostname)


if __name__ == '__main__':
    unittest.main(verbosity=2)
